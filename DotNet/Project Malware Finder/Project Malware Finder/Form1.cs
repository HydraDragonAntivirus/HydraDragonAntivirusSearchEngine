using log4net.Config;
using System.Collections.Concurrent;
using System.Net;
using System.Text;
using System.Text.RegularExpressions;

namespace Project_Malware_Finder
{
    public partial class Form1 : Form
    {
        // File lists for scanning and whitelist.
        private readonly List<string> malwareFiles = new List<string>();
        private readonly List<string> ddosFiles = new List<string>();
        private readonly List<string> phishingFiles = new List<string>();
        private readonly List<string> whitelistFiles = new List<string>();
        private string lastPath = "";

        // Scanner instance – created when the user clicks Start Scan.
        private Scanner scanner;
        // Cancellation token source to allow stopping the scan.
        CancellationTokenSource cts;
        // A full log list to support search and saving.
        private readonly List<string> fullLogList = new List<string>();

        public Form1()
        {
            InitializeComponent();
            XmlConfigurator.Configure();
        }

        private void Form1_Load(object sender, EventArgs e)
        {
            // Set default settings – these values are user-configurable in the UI.
            textBoxMaxDepth.Text = "10";
            textBoxMaxThreads.Text = "100";
            textBoxCsvMaxLines.Text = "10000"; // Maximum lines (including header)
            textBoxCsvMaxSize.Text = "2097152"; // 2 MB in bytes
            textBoxOutputFile.Text = "BulkReport.csv";
            textBoxWhitelistOutputFile.Text = "WhitelistReport.csv";

            textBoxCategoryMalicious.Text = "20";
            textBoxCategoryPhishing.Text = "7";
            textBoxCategoryDdos.Text = "18";
            textBoxCategoryBenign.Text = ""; // empty for benign
            textBoxCommentTemplate.Text = "Related with ip address detected by heuristics of https://github.com/HydraDragonAntivirus/HydraDragonAntivirusSearchEngine (Source IP: {ip}, Source URL: {source_url}, Discovered URL: {discovered_url}, Verdict: {verdict})";
        }

        #region Event Handlers (as referenced in Designer)

        // Start Scan button clicked.
        private async void button1_Click(object sender, EventArgs e)
        {
            // Read settings from UI controls.
            if (!int.TryParse(textBoxMaxDepth.Text, out int maxDepth))
                maxDepth = 10;
            if (!int.TryParse(textBoxMaxThreads.Text, out int maxThreads))
                maxThreads = 100;
            if (!int.TryParse(textBoxCsvMaxLines.Text, out int csvMaxLines))
                csvMaxLines = 10000;
            if (!int.TryParse(textBoxCsvMaxSize.Text, out int csvMaxSize))
                csvMaxSize = 2097152;

            string outputFileName = textBoxOutputFile.Text;
            string whitelistOutputFileName = textBoxWhitelistOutputFile.Text;
            string categoryMalicious = textBoxCategoryMalicious.Text;
            string categoryPhishing = textBoxCategoryPhishing.Text;
            string categoryDdos = textBoxCategoryDdos.Text;
            string categoryBenign = textBoxCategoryBenign.Text;

            cts = new CancellationTokenSource();

            string commentTemplate = textBoxCommentTemplate.Text;

            // Initialize real‑time Bulk CSV file with header if enabled.
            if (checkBoxRealTimeCsvBulk.Checked && !string.IsNullOrEmpty(textBoxRealTimeCsvBulkFile.Text))
            {
                File.WriteAllText(textBoxRealTimeCsvBulkFile.Text, "IP,Categories,ReportDate,Comment" + Environment.NewLine);
            }
            // Initialize real‑time Whitelist CSV file with header if enabled.
            if (checkBoxRealTimeCsvWhitelist.Checked && !string.IsNullOrEmpty(textBoxRealTimeCsvWhitelistFile.Text))
            {
                File.WriteAllText(textBoxRealTimeCsvWhitelistFile.Text, "IP,Source,ReportDate,Comment" + Environment.NewLine);
            }

            bool scanKnownActive = checkBoxScanKnownActive.Checked;
            scanner = new Scanner(
                malwareFiles, ddosFiles, phishingFiles, whitelistFiles,
                maxDepth, maxThreads,
                categoryMalicious, categoryPhishing, categoryDdos, categoryBenign,
                csvMaxLines, csvMaxSize,
                outputFileName, whitelistOutputFileName,
                UpdateLog, UpdateProgress,
                AppendBulkCsvLineToFile, AppendWhitelistCsvLineToFile,
                commentTemplate,
                AddIPv4ToListBox,
                AddIPv6ToListBox);

            await scanner.StartScanAsync(cts.Token);

            // Validate main CSV limits.
            int totalLines = scanner.BulkCsvLines.Count;
            string csvContent = string.Join("\n", scanner.BulkCsvLines);
            int csvSizeInBytes = Encoding.UTF8.GetByteCount(csvContent);

            if (totalLines > csvMaxLines + 1) // +1 for header
            {
                MessageBox.Show("CSV output exceeds the maximum allowed number of lines (" + csvMaxLines + ").");
            }
            else if (csvSizeInBytes > csvMaxSize)
            {
                MessageBox.Show("CSV output exceeds the maximum allowed file size (" + csvMaxSize + " bytes).");
            }
            else
            {
                // Write both CSV outputs.
                File.WriteAllLines(outputFileName, scanner.BulkCsvLines, Encoding.UTF8);
                File.WriteAllLines(whitelistOutputFileName, scanner.WhitelistCsvLines, Encoding.UTF8);
                MessageBox.Show("Scan completed and CSV files generated successfully.");
            }
        }

        // Stop Scan button clicked.
        private void btnStopScan_Click(object sender, EventArgs e)
        {
            if (cts != null)
            {
                cts.Cancel();
                UpdateLog("Scan cancellation requested.");
            }
        }

        // Update IPv4 list box with the .txt file name.
        private void AddIPv4ToListBox(string fileName)
        {
            if (listBoxIPv4.InvokeRequired)
            {
                listBoxIPv4.Invoke(new Action(() => listBoxIPv4.Items.Add(fileName)));
            }
            else
            {
                listBoxIPv4.Items.Add(fileName);
            }
        }

        // Update IPv6 list box with the .txt file name.
        private void AddIPv6ToListBox(string fileName)
        {
            if (listBoxIPv6.InvokeRequired)
            {
                listBoxIPv6.Invoke(new Action(() => listBoxIPv6.Items.Add(fileName)));
            }
            else
            {
                listBoxIPv6.Items.Add(fileName);
            }
        }

        // Clear Log button clicked.
        private void btnClearLog_Click(object sender, EventArgs e)
        {
            listBoxLog.Items.Clear();
        }

        #region Malware List Handlers

        // "Select" malware file.
        private void button2_Click(object sender, EventArgs e)
        {
            OpenFileDialog ofd = new OpenFileDialog
            {
                Filter = "Text Files|*.txt",
                InitialDirectory = string.IsNullOrEmpty(lastPath) ? Environment.CurrentDirectory : lastPath
            };

            if (ofd.ShowDialog() == DialogResult.OK)
            {
                string filePath = ofd.FileName;
                lastPath = Path.GetDirectoryName(filePath);
                malwareFiles.Add(filePath);
                listBoxMalware.Items.Add(filePath);
            }
        }

        // "Add" malware file (via text input).
        private void button3_Click(object sender, EventArgs e)
        {
            if (File.Exists(textBoxMalwareInput.Text))
            {
                if (textBoxMalwareInput.Text.EndsWith(".txt", StringComparison.OrdinalIgnoreCase))
                {
                    listBoxMalware.Items.Add(textBoxMalwareInput.Text);
                    malwareFiles.Add(textBoxMalwareInput.Text);
                    textBoxMalwareInput.Clear();
                }
                else
                {
                    MessageBox.Show("File is not a txt file.");
                }
            }
            else
            {
                MessageBox.Show("File does not exist.");
            }
        }

        // "Delete Selected From Malware List" button.
        private void button6_Click(object sender, EventArgs e)
        {
            if (listBoxMalware.SelectedIndex >= 0)
            {
                int index = listBoxMalware.SelectedIndex;
                malwareFiles.RemoveAt(index);
                listBoxMalware.Items.RemoveAt(index);
            }
        }

        #endregion

        #region DDoS List Handlers

        // "Select" DDoS file.
        private void buttonSelectDdosFile_Click(object sender, EventArgs e)
        {
            OpenFileDialog ofd = new OpenFileDialog
            {
                Filter = "Text Files|*.txt",
                InitialDirectory = string.IsNullOrEmpty(lastPath) ? Environment.CurrentDirectory : lastPath
            };

            if (ofd.ShowDialog() == DialogResult.OK)
            {
                string filePath = ofd.FileName;
                lastPath = Path.GetDirectoryName(filePath);
                ddosFiles.Add(filePath);
                listBoxDdos.Items.Add(filePath);
            }
        }

        // "Add" DDoS file (via text input).
        private void buttonAddDdosFile_Click(object sender, EventArgs e)
        {
            if (File.Exists(textBoxDdosInput.Text))
            {
                if (textBoxDdosInput.Text.EndsWith(".txt", StringComparison.OrdinalIgnoreCase))
                {
                    listBoxDdos.Items.Add(textBoxDdosInput.Text);
                    ddosFiles.Add(textBoxDdosInput.Text);
                    textBoxDdosInput.Clear();
                }
                else
                {
                    MessageBox.Show("File is not a txt file.");
                }
            }
            else
            {
                MessageBox.Show("File does not exist.");
            }
        }

        // "Delete Selected From DDoS List" button.
        private void buttonDeleteDdosFile_Click(object sender, EventArgs e)
        {
            if (listBoxDdos.SelectedIndex >= 0)
            {
                int index = listBoxDdos.SelectedIndex;
                ddosFiles.RemoveAt(index);
                listBoxDdos.Items.RemoveAt(index);
            }
        }

        #endregion

        #region Phishing List Handlers

        // "Select" Phishing file.
        private void buttonSelectPhishingFile_Click(object sender, EventArgs e)
        {
            OpenFileDialog ofd = new OpenFileDialog
            {
                Filter = "Text Files|*.txt",
                InitialDirectory = string.IsNullOrEmpty(lastPath) ? Environment.CurrentDirectory : lastPath
            };

            if (ofd.ShowDialog() == DialogResult.OK)
            {
                string filePath = ofd.FileName;
                lastPath = Path.GetDirectoryName(filePath);
                phishingFiles.Add(filePath);
                listBoxPhishing.Items.Add(filePath);
            }
        }

        // "Add" Phishing file (via text input).
        private void buttonAddPhishingFile_Click(object sender, EventArgs e)
        {
            if (File.Exists(textBoxPhishingInput.Text))
            {
                if (textBoxPhishingInput.Text.EndsWith(".txt", StringComparison.OrdinalIgnoreCase))
                {
                    listBoxPhishing.Items.Add(textBoxPhishingInput.Text);
                    phishingFiles.Add(textBoxPhishingInput.Text);
                    textBoxPhishingInput.Clear();
                }
                else
                {
                    MessageBox.Show("File is not a txt file.");
                }
            }
            else
            {
                MessageBox.Show("File does not exist.");
            }
        }

        // "Delete Selected From Phishing List" button.
        private void buttonDeletePhishingFile_Click(object sender, EventArgs e)
        {
            if (listBoxPhishing.SelectedIndex >= 0)
            {
                int index = listBoxPhishing.SelectedIndex;
                phishingFiles.RemoveAt(index);
                listBoxPhishing.Items.RemoveAt(index);
            }
        }

        #endregion

        #region Whitelist List Handlers

        // "Select" whitelist file.
        private void button5_Click(object sender, EventArgs e)
        {
            OpenFileDialog ofd = new OpenFileDialog
            {
                Filter = "Text Files|*.txt",
                InitialDirectory = string.IsNullOrEmpty(lastPath) ? Environment.CurrentDirectory : lastPath
            };

            if (ofd.ShowDialog() == DialogResult.OK)
            {
                string filePath = ofd.FileName;
                lastPath = Path.GetDirectoryName(filePath);
                whitelistFiles.Add(filePath);
                listBoxWhitelist.Items.Add(filePath);
            }
        }

        // "Add" whitelist file (via text input).
        private void button4_Click(object sender, EventArgs e)
        {
            if (File.Exists(textBoxWhitelistInput.Text))
            {
                if (textBoxWhitelistInput.Text.EndsWith(".txt", StringComparison.OrdinalIgnoreCase))
                {
                    listBoxWhitelist.Items.Add(textBoxWhitelistInput.Text);
                    whitelistFiles.Add(textBoxWhitelistInput.Text);
                    textBoxWhitelistInput.Clear();
                }
                else
                {
                    MessageBox.Show("File is not a txt file.");
                }
            }
            else
            {
                MessageBox.Show("File does not exist.");
            }
        }

        // "Delete Selected From Whitelist" button.
        private void button7_Click(object sender, EventArgs e)
        {
            if (listBoxWhitelist.SelectedIndex >= 0)
            {
                int index = listBoxWhitelist.SelectedIndex;
                whitelistFiles.RemoveAt(index);
                listBoxWhitelist.Items.RemoveAt(index);
            }
        }

        #endregion

        #endregion

        #region UI Helper Methods

        // Thread-safe log updater.
        private bool realtimeLogErrorShown = false;

        private void UpdateLog(string message)
        {
            string logEntry = $"{DateTime.Now}: {message}";

            // Update listBoxLog in a thread-safe manner.
            if (listBoxLog.InvokeRequired)
            {
                listBoxLog.Invoke(new Action(() => listBoxLog.Items.Add(logEntry)));
            }
            else
            {
                listBoxLog.Items.Add(logEntry);
            }

            // Realtime log saving to file.
            if (checkBoxRealTimeSave.Checked && !string.IsNullOrEmpty(textBoxRealTimeFile.Text))
            {
                try
                {
                    File.AppendAllText(textBoxRealTimeFile.Text, logEntry + Environment.NewLine);
                }
                catch (Exception ex)
                {
                    if (!realtimeLogErrorShown)
                    {
                        realtimeLogErrorShown = true;
                        // Instead of a MessageBox, append the error to the log (or update a status label)
                        if (listBoxLog.InvokeRequired)
                        {
                            listBoxLog.Invoke(new Action(() => listBoxLog.Items.Add("Error saving realtime log: " + ex.Message)));
                        }
                        else
                        {
                            listBoxLog.Items.Add("Error saving realtime log: " + ex.Message);
                        }
                    }
                }
            }
        }

        // Thread-safe progress updater.
        private void UpdateProgress(int current, int total)
        {
            if (progressBarScan.InvokeRequired)
            {
                progressBarScan.Invoke(new Action(() =>
                {
                    progressBarScan.Maximum = total;
                    progressBarScan.Value = current;
                    labelProgress.Text = $"{current} / {total}";
                }));
            }
            else
            {
                progressBarScan.Maximum = total;
                progressBarScan.Value = current;
                labelProgress.Text = $"{current} / {total}";
            }
        }

        private bool realtimeBulkCsvErrorShown = false;
        private bool realtimeWhitelistCsvErrorShown = false;

        // Real-time appending for Bulk CSV lines.
        private void AppendBulkCsvLineToFile(string csvLine)
        {
            // Make sure checkBoxRealTimeCsvBulk and textBoxRealTimeCsvBulkFile exist on your form.
            if (checkBoxRealTimeCsvBulk.Checked && !string.IsNullOrEmpty(textBoxRealTimeCsvBulkFile.Text))
            {
                try
                {
                    File.AppendAllText(textBoxRealTimeCsvBulkFile.Text, csvLine + Environment.NewLine);
                }
                catch (Exception ex)
                {
                    if (!realtimeBulkCsvErrorShown)
                    {
                        realtimeBulkCsvErrorShown = true;
                        MessageBox.Show("Error saving Bulk CSV line: " + ex.Message, "Bulk CSV Error", MessageBoxButtons.OK, MessageBoxIcon.Error);
                    }
                }
            }
        }

        // Real-time appending for Whitelist CSV lines.
        private void AppendWhitelistCsvLineToFile(string csvLine)
        {
            // Make sure checkBoxRealTimeCsvWhitelist and textBoxRealTimeCsvWhitelistFile exist on your form.
            if (checkBoxRealTimeCsvWhitelist.Checked && !string.IsNullOrEmpty(textBoxRealTimeCsvWhitelistFile.Text))
            {
                try
                {
                    File.AppendAllText(textBoxRealTimeCsvWhitelistFile.Text, csvLine + Environment.NewLine);
                }
                catch (Exception ex)
                {
                    if (!realtimeWhitelistCsvErrorShown)
                    {
                        realtimeWhitelistCsvErrorShown = true;
                        MessageBox.Show("Error saving Whitelist CSV line: " + ex.Message, "Whitelist CSV Error", MessageBoxButtons.OK, MessageBoxIcon.Error);
                    }
                }
            }
        }

        #endregion

        #region Scanner and Helper Classes

        /// <summary>
        /// Scanner class:
        /// Loads seeds from files (from three lists), performs HTTP scans concurrently, recursively discovers IPs,
        /// and builds two CSV reports (one for bulk results and one for whitelisted IPs).
        /// </summary>
        public class Scanner
        {
            private readonly List<string> malwareFiles;
            private readonly List<string> ddosFiles;
            private readonly List<string> phishingFiles;
            private readonly List<string> whitelistFiles;
            private readonly int maxDepth;
            private readonly int maxThreads;
            private readonly string categoryMalicious;
            private readonly string categoryPhishing;
            private readonly string categoryDdos;
            private readonly string categoryBenign;
            private readonly int csvMaxLines;
            private readonly int csvMaxSize;
            private readonly string outputFileName;
            private readonly string whitelistOutputFileName;
            private readonly string commentTemplate;

            private readonly Action<string> logCallback;
            private readonly Action<int, int> progressCallback;

            public List<string> BulkCsvLines { get; private set; } = new List<string>();
            public List<string> WhitelistCsvLines { get; private set; } = new List<string>();

            // Concurrent collections for seeds.
            private readonly ConcurrentQueue<Seed> seedQueue = new ConcurrentQueue<Seed>();
            private readonly ConcurrentDictionary<string, bool> processedIPs = new ConcurrentDictionary<string, bool>();

            // HashSet to store whitelisted IPs loaded from whitelist files.
            private readonly HashSet<string> whitelistedIPs = new HashSet<string>(StringComparer.OrdinalIgnoreCase);

            int totalSeeds = 0;
            int processedCount = 0;
            private readonly HttpClient httpClient = new HttpClient();

            private readonly Action<string> realTimeBulkCsvCallback;
            private readonly Action<string> realTimeWhitelistCsvCallback;
            private readonly Action<string> updateIPv4Callback;
            private readonly Action<string> updateIPv6Callback;
            private readonly HashSet<string> filesWithIPv4 = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
            private readonly HashSet<string> filesWithIPv6 = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
            private readonly object fileLock = new object();
            private readonly bool scanKnownActive;

            public Scanner(
                List<string> malwareFiles,
                List<string> ddosFiles,
                List<string> phishingFiles,
                List<string> whitelistFiles,
                int maxDepth,
                int maxThreads,
                string categoryMalicious,
                string categoryPhishing,
                string categoryDdos,
                string categoryBenign,
                int csvMaxLines,
                int csvMaxSize,
                string outputFileName,
                string whitelistOutputFileName,
                Action<string> logCallback,
                Action<int, int> progressCallback,
                Action<string> realTimeBulkCsvCallback = null,
                Action<string> realTimeWhitelistCsvCallback = null,
                string commentTemplate = null,
                Action<string> updateIPv4Callback = null,
                Action<string> updateIPv6Callback = null,
                bool scanKnownActive = false)
            {
                this.malwareFiles = malwareFiles;
                this.ddosFiles = ddosFiles;
                this.phishingFiles = phishingFiles;
                this.whitelistFiles = whitelistFiles;
                this.maxDepth = maxDepth;
                this.maxThreads = maxThreads;
                this.categoryMalicious = categoryMalicious;
                this.categoryPhishing = categoryPhishing;
                this.categoryDdos = categoryDdos;
                this.categoryBenign = categoryBenign;
                this.csvMaxLines = csvMaxLines;
                this.csvMaxSize = csvMaxSize;
                this.outputFileName = outputFileName;
                this.whitelistOutputFileName = whitelistOutputFileName;
                this.logCallback = logCallback;
                this.progressCallback = progressCallback;
                this.realTimeBulkCsvCallback = realTimeBulkCsvCallback;
                this.realTimeWhitelistCsvCallback = realTimeWhitelistCsvCallback;
                this.commentTemplate = commentTemplate ?? "Related with ip address detected by heuristics of https://github.com/HydraDragonAntivirus/HydraDragonAntivirusSearchEngine (Source IP: {ip}, Source URL: {source_url}, Discovered URL: {discovered_url}, Verdict: {verdict})";
                this.updateIPv4Callback = updateIPv4Callback;
                this.updateIPv6Callback = updateIPv6Callback;
                this.scanKnownActive = scanKnownActive;
            }

            public async Task StartScanAsync(CancellationToken token)
            {
                // First, process whitelist files.
                await LoadWhitelistSetAsync(token);

                // Start a background task to refresh the whitelist periodically.
                var whitelistRefreshTask = Task.Run(async () =>
                {
                    while (!token.IsCancellationRequested)
                    {
                        try
                        {
                            await Task.Delay(TimeSpan.FromMinutes(1), token); // adjust refresh interval as needed
                            await RefreshWhitelistAsync(token);
                        }
                        catch (TaskCanceledException)
                        {
                            break;
                        }
                    }
                }, token);

                // Now process blacklist seeds from malware, DDoS, and phishing file lists.
                await LoadSeedsFromFileListAsync(malwareFiles, "malicious", token);
                await LoadSeedsFromFileListAsync(ddosFiles, "ddos", token);
                await LoadSeedsFromFileListAsync(phishingFiles, "phishing", token);
                // Note: whitelistFiles are NOT processed here to avoid duplicate loading.

                totalSeeds = seedQueue.Count;
                progressCallback(processedCount, totalSeeds);

                List<Task> workers = new List<Task>();
                for (int i = 0; i < maxThreads; i++)
                {
                    workers.Add(Task.Run(() => WorkerAsync(token), token));
                }

                await Task.WhenAll(workers);
                logCallback("Scanning completed. Processed " + processedCount + " seeds.");
            }

            // This method refreshes the whitelist from all whitelist files.
            private async Task RefreshWhitelistAsync(CancellationToken token)
            {
                var updatedWhitelist = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
                foreach (var file in whitelistFiles.Where(f => Path.GetExtension(f).Equals(".txt", StringComparison.OrdinalIgnoreCase)))
                {
                    if (token.IsCancellationRequested)
                        break;
                    try
                    {
                        using var reader = new StreamReader(file);
                        {
                            string line;
                            while ((line = await reader.ReadLineAsync()) != null && !token.IsCancellationRequested)
                            {
                                string trimmed = line.Trim();
                                if (!string.IsNullOrEmpty(trimmed))
                                {
                                    updatedWhitelist.Add(trimmed);
                                }
                            }
                        }
                    }
                    catch (Exception ex)
                    {
                        logCallback("Error refreshing whitelist from " + file + ": " + ex.Message);
                    }
                }
                // Update the global whitelist set atomically.
                lock (whitelistedIPs)
                {
                    whitelistedIPs.Clear();
                    foreach (var ip in updatedWhitelist)
                    {
                        whitelistedIPs.Add(ip);
                    }
                }
                logCallback("Whitelist refreshed. Total whitelist IPs: " + whitelistedIPs.Count);
            }

            /// <summary>
            /// Loads all whitelist files into the whitelistedIPs HashSet asynchronously.
            /// </summary>
            private async Task LoadWhitelistSetAsync(CancellationToken token)
            {
                // Use a local bag for whitelist IPs if needed
                ConcurrentBag<string> loadedWhitelistIPs = new ConcurrentBag<string>();

                // Process each whitelist file once.
                var tasks = whitelistFiles.Where(file =>
                                Path.GetExtension(file).Equals(".txt", StringComparison.OrdinalIgnoreCase))
                    .Select(async file =>
                    {
                        if (token.IsCancellationRequested)
                            return;

                        logCallback($"Loading whitelist file: {file}");

                        bool addedIPv4 = false;
                        bool addedIPv6 = false;
                        string fileName = Path.GetFileName(file);

                        // Define regex patterns for IPv4 and IPv6.
                        Regex ipv4Pattern = new Regex(@"^(?:[0-9]{1,3}\.){3}[0-9]{1,3}$");
                        Regex ipv6Pattern = new Regex(@"^(?:[A-Fa-f0-9]{1,4}:){2,7}[A-Fa-f0-9]{1,4}$");

                        using (var reader = new StreamReader(file))
                        {
                            string line;
                            while ((line = await reader.ReadLineAsync()) != null)
                            {
                                string trimmed = line.Trim();
                                if (!string.IsNullOrEmpty(trimmed))
                                {
                                    // Add the IP to the whitelist bag.
                                    loadedWhitelistIPs.Add(trimmed);
                                    // Also add it to the global whitelist set.
                                    lock (whitelistedIPs)
                                    {
                                        whitelistedIPs.Add(trimmed);
                                    }
                                    // Check if it is IPv4 or IPv6.
                                    if (ipv4Pattern.IsMatch(trimmed))
                                        addedIPv4 = true;
                                    else if (ipv6Pattern.IsMatch(trimmed))
                                        addedIPv6 = true;
                                }
                            }
                        }
                        // Update UI list boxes if at least one valid IP was found.
                        if (addedIPv4)
                            updateIPv4Callback?.Invoke(fileName);
                        if (addedIPv6)
                            updateIPv6Callback?.Invoke(fileName);

                        logCallback($"Finished loading whitelist file: {file}");
                    }).ToList();

                await Task.WhenAll(tasks);
            }

            /// <summary>
            /// Loads seeds from a given list of files. If an IP is whitelisted, it is recorded in the whitelist CSV
            /// and not enqueued; otherwise, a new seed is enqueued.
            /// </summary>
            private async Task LoadSeedsFromFileListAsync(List<string> fileList, string defaultSourceType, CancellationToken token)
            {
               
                var ipv4Regex = new Regex(@"\b(?<ip>(?:[0-9]{1,3}\.){3}[0-9]{1,3})(?::(?<port>[0-9]{1,5}))?\b", RegexOptions.Compiled);
                var ipv6Regex = new Regex(@"\b(?<ip>(?:[A-Fa-f0-9]{1,4}:){2,7}[A-Fa-f0-9]{1,4})(?::(?<port>[0-9]{1,5}))?\b", RegexOptions.Compiled);

                
                var tasks = fileList.Where(file => Path.GetExtension(file).Equals(".txt", StringComparison.OrdinalIgnoreCase)).Select(async file =>
                    {
                        if (token.IsCancellationRequested)
                            return;

                        logCallback($"Loading file: {file}");

                    
                        using (var sr = new StreamReader(file))
                        {
                            string line;
                            var lineTasks = new List<Task>();

                            while ((line = await sr.ReadLineAsync()) != null)
                            {
                                if (token.IsCancellationRequested)
                                    break;

                                string trimmed = line.Trim();
                                if (string.IsNullOrEmpty(trimmed))
                                    continue;

                                 
                                lineTasks.Add(Task.Run(async () =>
                                {
                                    
                                    var ipv4Matches = ipv4Regex.Matches(trimmed);
                                    var ipv6Matches = ipv6Regex.Matches(trimmed);


                                   
                                    var ipv4Tasks = ipv4Matches.Cast<Match>().Select(match => ProcessMatch(match, "ipv4", file, trimmed, defaultSourceType)).ToList();

                                    var ipv6Tasks = ipv6Matches.Cast<Match>().Select(match => ProcessMatch(match, "ipv6", file, trimmed, defaultSourceType)).ToList();

                                    await Task.WhenAll(ipv4Tasks.Concat(ipv6Tasks));
                                }));
                            }

                        
                            await Task.WhenAll(lineTasks);
                        }

                        logCallback($"Finished loading file: {file}");
                    }).ToList();

         
                await Task.WhenAll(tasks);
            }

            /// <summary>
            /// Asynchronously processes a regex match by checking the whitelist and either recording
            /// the IP in the whitelist CSV or enqueuing it for scanning.
            /// </summary>
            public async Task ProcessMatch(Match match, string version, string file, string trimmed, string defaultSourceType)
            {
                string ip = match.Groups["ip"].Value;
                int? port = match.Groups["port"].Success ? (int?)int.Parse(match.Groups["port"].Value) : null;

                if (processedIPs.ContainsKey(ip))
                    return;

                // Get the file name without its full path.
                string fileName = Path.GetFileName(file);

                // Use the appropriate callback based on the IP version.
                if (version.Equals("ipv4", StringComparison.OrdinalIgnoreCase))
                {
                    lock (fileLock)
                    {
                        if (!filesWithIPv4.Contains(fileName))
                        {
                            filesWithIPv4.Add(fileName);
                            updateIPv4Callback?.Invoke(fileName);
                        }
                    }
                }
                else if (version.Equals("ipv6", StringComparison.OrdinalIgnoreCase))
                {
                    lock (fileLock)
                    {
                        if (!filesWithIPv6.Contains(fileName))
                        {
                            filesWithIPv6.Add(fileName);
                            updateIPv6Callback?.Invoke(fileName);
                        }
                    }
                }

                // Existing processing for whitelist/enqueue logic...
                bool isWhitelisted = whitelistedIPs.Contains(ip);
                if (isWhitelisted)
                {
                    processedIPs.TryAdd(ip, true);
                    string reportDate = DateTime.UtcNow.ToString("o");
                    string comment = $"Whitelisted from file: {file}";
                    string csvLine = $"{ip},\"whitelist\",{reportDate},\"{EscapeCsvField(comment)}\"";
                    lock (WhitelistCsvLines)
                    {
                        if (WhitelistCsvLines.Count < csvMaxLines + 1)
                        {
                            WhitelistCsvLines.Add(csvLine);
                        }
                    }
                    realTimeWhitelistCsvCallback?.Invoke(csvLine);
                }
                else
                {
                    EnqueueSeed(new Seed(ip, defaultSourceType, version, port, 1, trimmed));
                }
                await Task.CompletedTask;
            }

            private void EnqueueSeed(Seed seed)
            {
                if (processedIPs.TryAdd(seed.IP, true))
                {
                    seedQueue.Enqueue(seed);
                }
            }

            private async Task WorkerAsync(CancellationToken token)
            {
                while (!token.IsCancellationRequested)
                {
                    if (seedQueue.TryDequeue(out Seed seed))
                    {
                        await ProcessSeedAsync(seed, token);
                        processedCount++;
                        progressCallback(processedCount, totalSeeds);
                    }
                    else
                    {
                        break;
                    }
                }
            }

            public async Task ProcessSeedAsync(Seed seed, CancellationToken token)
            {
                if (seed.Depth > maxDepth)
                    return;

                string url = seed.GetUrl();
                logCallback("Processing: " + url);

                try
                {
                    var response = await httpClient.GetAsync(url, token);
                    if (!response.IsSuccessStatusCode)
                    {
                        logCallback($"Failed: {url} Status: {response.StatusCode}");
                        return;
                    }

                    string content = await response.Content.ReadAsStringAsync();
                    if (string.IsNullOrEmpty(content))
                        return;

                    logCallback("Visited: " + url);

                    string category = seed.SourceType switch
                    {
                        "malicious" => categoryMalicious,
                        "phishing" => categoryPhishing,
                        "ddos" => categoryDdos,
                        _ => categoryBenign
                    };
                    string reportDate = DateTime.UtcNow.ToString("o");

                    // Build the comment using the template
                    string comment = commentTemplate
                        .Replace("{ip}", seed.IP)
                        .Replace("{source_url}", seed.SourceUrl)
                        .Replace("{discovered_url}", url)
                        .Replace("{verdict}", seed.SourceType);

                    if (comment.Length > 1024)
                    {
                        comment = comment.Substring(0, 1024); // Truncate if necessary
                    }
                    string csvLine = $"{seed.IP},\"{category}\",{reportDate},\"{EscapeCsvField(comment)}\"";

                    BulkCsvLines.Add(csvLine);
                    realTimeBulkCsvCallback?.Invoke(csvLine);

                    if (seed.Depth < maxDepth)
                    {
                        var foundIPs = SeedHelper.ExtractIPAndPort(content);
                        var tasks = new List<Task>();

                        HashSet<string> processedIPSet = new HashSet<string>(processedIPs.Keys);
                        foreach (var (ip, port, version) in foundIPs)
                        {
                            if (!processedIPSet.Contains(ip))
                            {
                                tasks.Add(ProcessIPAsync(seed, ip, port, version, token));
                            }
                        }
                        await Task.WhenAll(tasks);
                    }
                }
                catch (Exception ex)
                {
                    logCallback("Error processing " + url + ": " + ex.Message);
                }
            }

            private async Task ProcessIPAsync(Seed seed, string ip, int? port, string version, CancellationToken token)
            {
                string newSourceType = seed.SourceType;

                // Always perform active check for 'malicious', and if user enabled it for others.
                if (seed.SourceType == "malicious" || (scanKnownActive && seed.SourceType != "whitelist"))
                {
                    bool active = await SeedHelper.IsActiveAndStaticAsync(ip, port ?? 0);
                    if (!active)
                    {
                        newSourceType = "benign (auto verdict)";
                    }
                }

                EnqueueSeed(new Seed(ip, newSourceType, version, port ?? 0, seed.Depth + 1, seed.SourceUrl));
            }

            private string EscapeCsvField(string field)
            {
                return field.Replace("\"", "\\\"");
            }
        }

        /// <summary>
        /// Helper class for IP validation and extraction.
        /// </summary>
        public static class SeedHelper
        {
            public static bool IsValidIP(string ip)
            {
                return IPAddress.TryParse(ip, out _);
            }

            public static List<(string ip, int? port, string version)> ExtractIPAndPort(string text)
            {
                List<(string ip, int? port, string version)> results = new List<(string, int?, string)>();

                string ipv4Pattern = @"\b(?<ip>(?:[0-9]{1,3}\.){3}[0-9]{1,3})(?::(?<port>[0-9]{1,5}))?\b";
                string ipv6Pattern = @"\b(?<ip>(?:[A-Fa-f0-9]{1,4}:){2,7}[A-Fa-f0-9]{1,4})(?::(?<port>[0-9]{1,5}))?\b";

                foreach (Match match in Regex.Matches(text, ipv4Pattern))
                {
                    string ip = match.Groups["ip"].Value;
                    int? port = match.Groups["port"].Success ? int.Parse(match.Groups["port"].Value) : (int?)null;
                    results.Add((ip, port, "ipv4"));
                }
                foreach (Match match in Regex.Matches(text, ipv6Pattern))
                {
                    string ip = match.Groups["ip"].Value;
                    int? port = match.Groups["port"].Success ? int.Parse(match.Groups["port"].Value) : (int?)null;
                    results.Add((ip, port, "ipv6"));
                }
                return results;
            }

            public static async Task<bool> IsActiveAndStaticAsync(string ip, int? port)
            {
                // Construct the URL using the given IP and port (if provided)
                string url = $"http://{ip}" + (port.HasValue ? $":{port.Value}" : "");

                try
                {
                    // Create a new HttpClient with a 5-second timeout.
                    using var httpClient = new HttpClient { Timeout = TimeSpan.FromSeconds(5) };
                    {
                        // Send the HTTP GET request. HttpClient follows redirects automatically.
                        HttpResponseMessage response = await httpClient.GetAsync(url);

                        // Check if the response status is 200 (OK)
                        if (!response.IsSuccessStatusCode)
                            return false;

                        // Get the final URL after following any redirects.
                        Uri finalUri = response.RequestMessage.RequestUri;
                        if (finalUri == null)
                            return false;

                        string finalHostname = finalUri.Host;
                        // If the final port is not explicitly set, default to port 80.
                        int finalPort = finalUri.Port > 0 ? finalUri.Port : 80;
                        int expectedPort = port ?? 80;

                        // Verify that the final hostname is a valid IP and matches the original IP,
                        // and that the final port matches the expected port.
                        if (!string.IsNullOrEmpty(finalHostname) &&
                            IsValidIP(finalHostname) &&
                            finalHostname == ip &&
                            finalPort == expectedPort)
                        {
                            return true;
                        }
                        return false;
                    }
                }
                catch (Exception ex)
                {
                    // Optionally log the error
                    Console.Error.WriteLine($"Active/static check failed for {url}: {ex.Message}");
                    return false;
                }
            }
        }
            /// <summary>
            /// The Seed class holds data for an individual IP seed.
            /// </summary>
            public class Seed
        {
            public string IP { get; }
            public string SourceType { get; }
            public string Version { get; }
            public int? Port { get; }
            public int Depth { get; }
            public string SourceUrl { get; }

            public Seed(string ip, string sourceType, string version, int? port, int depth, string sourceUrl)
            {
                IP = ip;
                SourceType = sourceType;
                Version = version;
                Port = port;
                Depth = depth;
                SourceUrl = sourceUrl;
            }

            public string GetUrl()
            {
                return Port.HasValue ? $"http://{IP}:{Port}" : $"http://{IP}";
            }
        }

        // Filters the log listbox based on the search term entered.
        private void textBoxSearch_TextChanged(object sender, EventArgs e)
        {
            string filter = textBoxSearch.Text.ToLowerInvariant();
            listBoxLog.Items.Clear();
            foreach (string entry in fullLogList)
            {
                if (entry.ToLowerInvariant().Contains(filter))
                {
                    listBoxLog.Items.Add(entry);
                }
            }
        }


        // Event handler for buttonSaveLog Click
        private void buttonSaveLog_Click(object sender, EventArgs e)
        {
            var sfd = new SaveFileDialog
            {
                Filter = "Text Files|*.txt"
            };

            if (sfd.ShowDialog() == DialogResult.OK)
            {
                File.WriteAllLines(sfd.FileName, fullLogList);
                MessageBox.Show("Log saved successfully.");
            }
        }

        #endregion

        private void tabPageSettings_Click(object sender, EventArgs e)
        {
            // Optional settings tab click handler.
        }
    }
}
